%%
%% This file is part of Triq - Trifork QuickCheck
%%
%% Copyright (c) 2010 by Trifork
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%  
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%

-module(triq_domain).

-include("triq_internal.hrl").

%% generators
-export([list/1, tuple/1, int/0, real/0, sized/2, elements/1, glet/2, any/0, atom/0, choose/2]).

%% using a generator
-export([generate/2, elem_gen/2]).

%% generator for lists 
list(ElemGen) ->
    #?DOM{kind={list,ElemGen},
	generate   = fun(#?DOM{kind={list,EG}},GS) -> 
				Len = random:uniform(1+ (GS div 3))-1,
				generate_list(Len, EG, GS)
		     end
	 }.


%% support function for generate({gen_list, ...})
generate_list(Len,_,_) when Len =< 0 ->
    [];
generate_list(_Len,_,0) ->
    [];
generate_list(Len,EG,GS) ->
    [generate(EG,GS-1) | generate_list(Len-1, EG, GS-1)].



tuple(ElemGen) ->
    #?DOM{kind={tuple,ElemGen},
	generate   = fun(#?DOM{kind={tuple,EG}},GS) -> 
				Len = random:uniform(1+ (GS div 3))-1,
				list_to_tuple(generate_list(Len, EG, GS))
		     end}.

elem_gen(_, #?DOM{kind=any}=ElemGen) ->
    ElemGen;
elem_gen(_, #?DOM{kind={list,ElemGen}}) ->
    ElemGen;
elem_gen(_, #?DOM{kind={tuple,ElemGen}}) ->
    ElemGen;
elem_gen(N, Gen) when is_tuple(Gen), N > 0, tuple_size(Gen) >= N ->
    element(N,Gen);
elem_gen(N, Gen) when is_list(Gen), N > 0, length(Gen) >= N ->
    lists:nth(N,Gen).

generate_int(_,GS) ->
    random:uniform(GS) - (GS div 2).

int() -> 
    #?DOM{kind=int,
	 generate  = fun generate_int/2
	}.

real() -> 
    #?DOM{kind=real,
	 generate  = fun(_,GS) -> (random:uniform()*GS) - (GS / 2) end
	}.

boolean() -> 
    #?DOM{kind=int,
	  generate  = fun(_,_) -> random:uniform(2) == 1 end
	 }.

rand(Min,Max,GS) ->
    Val = random:uniform(GS)-1+Min,
    if Val =< Max -> Val;
       true -> Max
    end.
	

atom() -> 
    #?DOM{kind=atom,
	  generate  = fun(_,GS) -> erlang:list_to_atom(generate(list(char()), rand(0,255,GS))) end
	 }.

char() -> 
    #?DOM{kind=char,
	  generate  = fun(_,_GS) -> random:uniform(256)-1 end
	 }.

glet(Gen1,FG2) -> 
    #?DOM{kind={glet,Gen1,FG2},
	 generate  = fun(#?DOM{kind={glet,G1,G2}},GS) -> 
			     Va = generate(G1, GS),
			     G = G2(Va),
			     generate(G,GS)
		     end
	}.

%%
%% This is the heart of the random structure generator
%%
generate(Gen=#?DOM{generate=GenFun}, GS) ->
    GenFun(Gen,GS);

generate(Dom, GS) ->
    generate_internal(Dom,GS).


generate_internal({call, Mod, Fun, Args},GS) 
  when is_atom(Mod), is_atom(Fun), is_list(Args) ->
    generate (apply(Mod,Fun,Args), GS);


%%
%% A tuple is generated by generating each element
%%
generate_internal({}, _) -> {};
generate_internal(T,GS) when is_tuple(T) ->
    TList = erlang:tuple_to_list(T),
    GList = lists:map(fun(TE) -> generate(TE,GS) end, TList),
    erlang:list_to_tuple(GList);

%%
%% for Lists, we traverse down the list and generate 
%% each head
%%
generate_internal([], _) -> [];
generate_internal([H|T], GS) -> [generate(H,GS)|generate(T,GS)];

%%
%% simple values that generate themselves
%%
generate_internal(V,_) when is_atom(V);
		   is_number(V);
		   is_list(V);
		   is_function(V)
		   ->
    V.





sized(Size,Gen) ->
    #?DOM{kind={sized, Gen, Size},
	  generate=fun(#?DOM{kind={sized,Gen2,Size2}}, _GS) ->
			   generate(Gen2, Size2)
		   end,
	  simplify=fun(#?DOM{kind={sized,Gen2,_}},Val) ->
			   triq_simplify:simplify_value (Gen2,Val)
		   end
	 }.

elements([]) -> undefined;
elements(L) when is_list(L) ->
    #?DOM{kind={elements,L,length(L)}, 
	 generate=fun(#?DOM{kind={elements,L2,Len}},_GS) ->			  
			  lists:nth(random:uniform(Len), L2)
		  end,
	 simplify=fun(_Dom,Val) -> Val end}.


any()  ->
    #?DOM{kind=any,
	  generate=fun(#?DOM{kind=any}=Dom,GS) ->
			   case random:uniform(6) of
			       1 -> generate(int(),GS div 2);
			       2 -> generate(real(),GS div 2);
			       3 -> generate(list(Dom),GS div 2);
			       4 -> generate(tuple(Dom),GS div 2);
			       5 -> generate(boolean(),GS div 2);
			       6 -> generate(atom(),GS div 2)
			   end
		   end
	 }.

choose(M,N) when is_integer(M), is_integer(N), M<N ->
    #?DOM{kind={choose,M,N},
	  generate=fun(_,_) ->
			   random:uniform(N-M+1) - 1 + M
		   end,
	  simplify=fun(_Dom,Val) when Val>M -> 
			   Val-1;
		      (_Dom,_) -> 
			   M
		   end}.
